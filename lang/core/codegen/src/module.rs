use crate::*;
use genotype_lang_core_tree::*;
use miette::Result;

/// Codegen module trait. It allows to accumulate and generate final module code.
pub trait GtlCodegenModule<'a> {
    type RenderModule: GtlRenderModule;

    type RenderState: GtlRenderState;

    type RenderContext: GtlRenderContext;

    // fn update<MutateFn: FnOnce(&mut GtlCodegenModuleAcc<Self::RenderContext>) -> ()>(
    //     &mut self,
    //     mutate_fn: MutateFn,
    // );

    // fn get(&self) -> &GtlCodegenModuleAcc<Self::RenderContext>;

    // fn apply_result(&mut self, result: GtlCodegenResult<'a, Self::RenderContext>) {
    //     self.update(|module| module.blocks.push(result.definitions().into()));
    // }

    fn render(
        &self,
        acc: GtlCodegenModuleAcc<'a, Self::RenderState, Self::RenderContext>,
        state: Self::RenderState,
        context: &mut Self::RenderContext,
    ) -> Result<String> {
        let mut blocks = vec![];

        let imports = acc
            .imports
            .iter()
            .map(|import| import.render(state, context))
            .collect::<Result<Vec<_>>>()?;
        blocks.push(Self::RenderModule::join_imports(&imports));

        blocks.extend(acc.blocks.clone());

        Ok(Self::RenderModule::join_blocks(&blocks))
    }
}

/// Codegen module accumulator struct. It holds the blocks and imports generated by the codegen process.
pub struct GtlCodegenModuleAcc<'a, RenderState, RenderContext> {
    blocks: Vec<String>,
    imports: Vec<
        Box<dyn GtlCodegenImport<'a, RenderState = RenderState, RenderContext = RenderContext>>,
    >,
}
