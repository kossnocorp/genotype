use genotype_lang_core_tree::*;
use genotype_parser::{GTAlias, GTDescriptor};
use miette::Result;
use std::fmt::Debug;

/// Codegen trait for target languages.
pub trait GtlCodegen<'a, RenderContext> {
    /// Generates code for a descriptor node.
    fn gen_descriptor(
        descriptor: &GTDescriptor,
    ) -> Result<GtlCodegenResultDescriptor<'a, RenderContext>>;

    /// Generates code for an alias node.
    fn gen_alias(alias: &GTAlias) -> Result<GtlCodegenResultAlias<'a, RenderContext>>;
}

/// Codegen result enum.
#[derive(Debug, PartialEq)]
pub enum GtlCodegenResult<'a, RenderContext> {
    /// Descriptor codegen result.
    Descriptor(GtlCodegenResultDescriptor<'a, RenderContext>),
    /// Alias codegen result.
    Alias(GtlCodegenResultAlias<'a, RenderContext>),
}

impl<'a, RenderContext> GtlCodegenResult<'a, RenderContext> {
    pub fn definitions(&self) -> &String {
        match self {
            GtlCodegenResult::Descriptor(result) => &result.definitions,
            GtlCodegenResult::Alias(result) => &result.definitions,
        }
    }

    pub fn resolve(&self) -> &GtlCodegenResolve<'a, RenderContext> {
        match self {
            GtlCodegenResult::Descriptor(result) => &result.resolve,
            GtlCodegenResult::Alias(result) => &result.resolve,
        }
    }
}

/// Descriptor codegen result.
#[derive(Debug, PartialEq)]
pub struct GtlCodegenResultDescriptor<'a, RenderContext> {
    /// Source code representation of a descriptor.
    pub inline: String,
    /// Definitions source code that shall be appended to the root level. It might be empty string.
    pub definitions: String,
    /// Codegen resolve containing the information to embed the generated code.
    pub resolve: GtlCodegenResolve<'a, RenderContext>,
}

/// Alias codegen result.
#[derive(Debug, PartialEq)]
pub struct GtlCodegenResultAlias<'a, RenderContext> {
    /// Definitions source code that shall be appended to the root level.
    pub definitions: String,
    /// Codegen resolve containing the information to embed the generated code.
    pub resolve: GtlCodegenResolve<'a, RenderContext>,
}

/// Codegen result resolve. It contains the relevant information to embed the generated code.
#[derive(Debug, PartialEq)]
pub struct GtlCodegenResolve<'a, RenderContext> {
    /// Imports generated by the input node.
    pub imports: Vec<Box<dyn GtlCodegenImport<'a, RenderContext = RenderContext>>>,
    /// Names claimed by the input node.
    pub claims: Vec<String>,
}

/// Codegen module trait. It allows to accumulate and generate final module code.
pub trait GtlCodegenModule<'a> {
    type RenderModule: GtlRenderModule;

    type RenderContext: GtlRenderContext;

    // fn update<MutateFn: FnOnce(&mut GtlCodegenModuleAcc<Self::RenderContext>) -> ()>(
    //     &mut self,
    //     mutate_fn: MutateFn,
    // );

    // fn get(&self) -> &GtlCodegenModuleAcc<Self::RenderContext>;

    // fn apply_result(&mut self, result: GtlCodegenResult<'a, Self::RenderContext>) {
    //     self.update(|module| module.blocks.push(result.definitions().into()));
    // }

    fn render(
        &self,
        acc: GtlCodegenModuleAcc<'a, Self::RenderContext>,
        context: &mut Self::RenderContext,
    ) -> Result<String> {
        let mut blocks = vec![];

        let imports = acc
            .imports
            .iter()
            .map(|import| import.render(context))
            .collect::<Result<Vec<_>>>()?;
        blocks.push(Self::RenderModule::join_imports(&imports));

        blocks.extend(acc.blocks.clone());

        Ok(Self::RenderModule::join_blocks(&blocks))
    }
}

/// Codegen module accumulator struct. It holds the blocks and imports generated by the codegen process.
pub struct GtlCodegenModuleAcc<'a, RenderContext> {
    blocks: Vec<String>,
    imports: Vec<Box<dyn GtlCodegenImport<'a, RenderContext = RenderContext>>>,
}

pub trait GtlCodegenImport<'a>: GtlImport + GtlRender<'a> {}

impl<'a, RenderContext> Debug for dyn GtlCodegenImport<'a, RenderContext = RenderContext> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("GtlImport")
            // [TODO]
            // .field("imports", &"<omitted>")
            .finish()
    }
}

impl<'a, RenderContext> PartialEq for dyn GtlCodegenImport<'a, RenderContext = RenderContext> {
    fn eq(&self, other: &Self) -> bool {
        // [TODO]
        true
    }
}
