use crate::*;
use std::fmt::Debug;

/// Codegen result resolve. It contains the relevant information to embed the generated code.
#[derive(Default, Debug, PartialEq, Clone)]
pub struct GtlRenderResolve<'a, RenderState, RenderContext>
where
    Box<dyn GtlRenderResolveImport<'a, RenderState, RenderContext>>: Clone,
{
    /// Imports generated by the input node.
    pub imports: Vec<Box<dyn GtlRenderResolveImport<'a, RenderState, RenderContext>>>,
    /// Exports generated by the input node.
    pub exports: Vec<GtlRenderResolveExport>,
}

pub trait GtlRenderResolveImport<'a, RenderState, RenderContext>:
    GtlImport + GtlRender<'a, RenderState = RenderState, RenderContext = RenderContext>
{
    fn clone_box(&self) -> Box<dyn GtlRenderResolveImport<'a, RenderState, RenderContext>>;
}

// Box<(dyn GtlRenderResolveImport<'_, RenderState, RenderContext> + 'static)>: Clone

impl<RenderState: GtlRenderState, RenderContext: GtlRenderContext> Clone
    for Box<dyn GtlRenderResolveImport<'_, RenderState, RenderContext>>
{
    fn clone(&self) -> Self {
        self.clone_box()
    }
}

impl<RenderState, RenderContext> Debug
    for dyn GtlRenderResolveImport<'_, RenderState, RenderContext>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("GtlCodegenImport")
            // [TODO]
            // .field("imports", &"<omitted>")
            .finish()
    }
}

impl<'a, RenderState, RenderContext> PartialEq
    for dyn GtlRenderResolveImport<'a, RenderState, RenderContext>
{
    fn eq(&self, _other: &Self) -> bool {
        // [TODO]
        true
    }
}

// impl<'a, RenderContext> Clone
//     for Box<dyn GtlRenderResolveImport<'a, RenderContext = RenderContext>>
// {
//     fn clone(&self) -> Self {
//         self.clone_box()
//     }
// }

#[derive(Debug, PartialEq, Clone)]
pub struct GtlRenderResolveExport {
    /// Exported identifier name.
    pub name: String,
}
